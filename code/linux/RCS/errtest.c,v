head	1.1;
access;
symbols;
locks; strict;
comment	@ * @;


1.1
date	2020.08.31.02.56.52;	author youngjam;	state Exp;
branches;
next	;


desc
@test file.
@


1.1
log
@Initial revision
@
text
@/*
 * 测试静态库和动态库的编译使用
 * 静态编译
 * gcc liberr.c -o liberr.o 编译目标文件
 * ar rcs liberr.a liberr.o 生成静态库
 * gcc errtest.c -o errtest -static -L. -lerr 静态编译测试文件,并指明库路径及加载库
 * 动态编译
 * gcc -shared -fPIC liberr.o -o liberr.so 生成动态库
 * gcc errtest.c -o errtest -L. -lerr 动态编译测试文件(库同名优先动态库)
 * LD_LIBRARY_PATH=$(pwd) ./errtest 指明动态库链接路径,运行文件
 */

#include <stdio.h>
#include <stdlib.h>
#include "liberr.h"

// #define ERR_QUIT_SKIP 1
// #define LOG_QUIT_SKIP 1

int main(void)
{
    FILE *pf;

    puts("Testing err_ret");
    if ((pf = fopen("foo", "r")) == NULL)
    {
        err_ret("%s %s", "err_ret:", "failed to open foo!");
    }

    puts("Testing log_ret");
    if ((pf = fopen("foo", "r")) == NULL)
    {
        log_ret("errtest.log", "%s %s", "log_ret:", "failed to open foo!");
    }

    #ifndef ERR_QUIT_SKIP
    puts("Testing err_quit");
    if ((pf = fopen("foo", "r")) == NULL)
    {
        err_quit("%s %s", "err_quit:", "failed to open foo!");
    }
    #endif

    #ifndef LOG_QUIT_SKIP
    puts("Testing log_quit");
    if ((pf = fopen("foo", "r")) == NULL)
    {
        log_quit("errtest.log", "%s %s", "log_quit:", "failed to open foo!");
    }
    #endif

    exit(EXIT_SUCCESS);
}@
