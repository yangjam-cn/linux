# c_cpp面试问题整理
## new_delete和malloc_free
1. new/delete为c++运算符，malloc和free是库函数
2. new/delete会自动调用构造函数和析构函数完成对象初始化和销毁，malloc和free只是申请和释放内存空间

## delete和delete []
1. delete只调用一次析构函数，delete[]调用内一个成员的析构函数
2. delete对应new，delete[]对应new []

## 继承优缺点
1. 类继承在编译时刻静态定义，可以直接使用
2. 类继承可以较方便地改变父类的实现
3. 无法在运行时改变父类的实现
4. 父类定义了子类的部分行为，任何改变都会影响子类的行为

## c++的性质（面向对象特点）
* 封装
  * 将客观事物抽象为类，每个类的数据和方法实行保护
* 继承
  * 实现继承  使用基类的属性和方法而无需额外编码
  * 可视继承  使用基类的接口和实现
  * 接口继承  仅使用属性和方法，实现滞后到派生类实现
* 多态

## 多态、虚函数、纯虚函数
### 多态
* 同一个方法在派生类和基类中的行为是不同的，方法的行为取决于调用该方法的对象，这种方法随上下文而异的行为称为多态
* 允许子类型的指针赋值给基类类型的指针
### 虚函数
* 多态的实现依赖虚函数，使用virtual声明
* 构造函数不能是虚函数，作为基类的析构函数应该声明为虚函数
* 友元不能是虚函数
### 纯虚函数
* virtual void func() = 0
* 含有纯虚函数的类称为抽象类，不能创建该类的对象

## 子类析构时要调用父类的析构函数吗
* 析构对象时，析构函数的顺序是先派生类的析构函数，然后调用基类的析构函数
* 构造对象时，先调用基类的构造函数，再调用派生类的构造函数

## “引用”
* 引用就是对象的别名，对引用的操作与对被引用变量的操作完全相同
* 声明引用对象时必须初始化
* 引用对象不分配内存空间
* 不能建立数组的引用

## 引用作为函数参数
1. 引用作为函数参数作用相当于指针参数
2. 引用作为函数参数，不产生实参副本；使用指针参数传递，在被调函数中会产生指针变量的副本

## 常引用
* 提高函数参数传递效率，同事保护被传递的参数不被调用函数改变

## 引用作为返回参数
* 优点在于不会在内存中产生返回值的副本
* 注意事项
  1. 不能返回局部变量的引用
  2. 不能返回被函数内部new分配的内存的引用
  3. 可以返回类成员的引用，但最好是const
  4. 流操作符重载返回值声明为引用，实现连续使用
  5. +-*/不能返回引用

## 引用与多态
* 基类的引用可以指向派生类对象

## 结构与联合
1. 结构和联合都是由多个不同数据类型成员组成，结构是分别占据内存空间，而联合同时只有一个成员占有内存空间
2. 对于联合的不同成员赋值会覆盖其他成员，结构成员间互不影响

## 重载和重写
* 重载是指允许存在多个同名函数，但是函数的参数列表不同
* 重写是指派生类重新定义基类虚函数的方法
1. 重载是编译器根据函数的不同参数列表对同名函数做修饰，形成不同的函数
2. 重写是基类定义虚函数后，当遇到对该函数调用时，动态调用属于子类的函数，函数地址在运行期绑定

## 多态的作用
1. 扩展代码模块，实现代码复用
2. 接口重用，派生类可以使用同一接口，但是实现细节不同

## 哪几种情况只能使用初始化列表，而不能使用赋值
* 当类中含有const、refernce成员变量，基类的构造函数需要初始化列表

## c++是不是类型安全的
* 不是，c++允许不同类型的指针之间可以强制转换

## main函数执行之前，还会执行什么代码
* 全局对象的构造函数会在main之前执行

## 描述内存分配方式及区别
* 静态存储区分配，内存在程序编译的时候分配，内存在程序的整个运行期间都存在
* 栈内存分配，执行函数时，函数内部的局部变量在栈上创建，函数结束时自动释放
* 堆空间分配，函数运行中使用malloc或new动态分配，直到使用free和delete释放

## struct和class的区别
* struct的成员默认是共有的，class的成员默认是私有的

## 若一个类没有成员变量与成员函数，其大小为多少
* sizeof(empty class) = 1

## const与#define的优点
* const作用：定义常量、修饰函数参数、修饰函数返回值
1. const常量有数据类型，而宏常量没有数据类型
2. const常量进行类型安全检查，#define只是进行字符替换

## 数组与指针的区别
1. 数组在静态区或栈上创建，而指针可以指向任意类型内存块
2. 将常量字符串赋给数组和字符串，其机制不同，数值是复制，指针是指向常量字符串
3. sizeof作用与数组是求数组大小，作用于指针是求指针大小

## 类成员函数的重载、覆盖和隐藏
### 成员函数重载
1. 相同的范围（在同一个类中）
2. 函数名字相同
3. 参数列表不同
4. virtual可有可无
### 覆盖（派生类函数覆盖基类函数）
1. 不同范围（基类和派生类）
2. 函数名字相同
3. 参数相同
4. 基类函数必须有virtual关键字
### 隐藏是派生类函数屏蔽同名基类函数
1. 如果派生类和基类函数同名不同参，无论有无virtual关键字，基类函数将隐藏
2. 如果派生类和基类函数同名同参，但是没有virtual关键字，基类函数将隐藏

## 在c++中调用c编译器编译后的函数，需要加extern “C”
* c++支持函数重载，c不支持函数重载，c++提供c链接指定符号extern “C”解决名字匹配问题
1. 在c++中引用c语言中的函数和变量、在包含c语言头文件时，需使用extern “C”
```cpp
extern "C"
{
  #include "cexp.h"
}
```
2. 在c语言文件中引用c++语言的函数和变量时，c++头文件应添加extern “C”，在c文件中c++函数声明为extern

## static全局变量、局部变量和函数有什么特别
* static全局变量在多文件程序中，static全局变量作用域限制在文件内，static全局变量只初始化一次
* static局部变量存储在静态存储区，程序运行期间均存在
* static函数将作用域限制在文件内，static函数在内存中仅有一份，而普通函数在每个被调用中维持一份拷贝

## volatile的含义
* 表明该函数可能会被意外的改变，不要使用该值在寄存器中的备份，每次使用时重新读取
1. 并行设备的硬件寄存器
2. 中断服务程序中会访问的非自动变量
3. 多线程中被多个任务共享的变量

## class和struct的区别
* 默认继承权限，class为private，struct为public
* 默认访问权限，class为private，struct为public
